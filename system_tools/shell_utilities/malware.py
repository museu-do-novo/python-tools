"""
ethical_pen_test.py - Ferramentas para testes de penetra√ß√£o √©ticos
AVISO: Use apenas em sistemas onde voc√™ tem permiss√£o expl√≠cita
"""

import shell_utilities as su
import os
import subprocess
import shutil
import sys
import ctypes
import winreg
from pathlib import Path
import socket
import json
from datetime import datetime

# ===========================================
# üîç 1. Coleta de Informa√ß√µes do Sistema
# ===========================================
def system_recon(verbose=True):
    """Coleta abrangente de informa√ß√µes do sistema"""
    data = {
        'timestamp': str(datetime.now()),
        'user': su.whoami(),
        'network': {
            'hostname': socket.gethostname(),
            'ip_local': socket.gethostbyname(socket.gethostname()),
            'interfaces': get_network_interfaces()
        },
        'system': su.uname(),
        'disks': su.df(),
        'processes': su.ps()[:20],  # Mostra apenas os 20 primeiros
        'env_vars': {k: os.environ.get(k, '') for k in ['USERNAME', 'COMPUTERNAME', 'APPDATA', 'TEMP']}
    }
    
    if verbose:
        su.message("Informa√ß√µes do sistema coletadas:", "success")
        print(json.dumps(data, indent=2, default=str))
    
    return data

def get_network_interfaces():
    """Lista interfaces de rede e configura√ß√µes"""
    try:
        import netifaces
        interfaces = {}
        for iface in netifaces.interfaces():
            addrs = netifaces.ifaddresses(iface)
            interfaces[iface] = addrs.get(netifaces.AF_INET, [])
        return interfaces
    except ImportError:
        return {"error": "netifaces module not installed"}

# ===========================================
# üîê 2. An√°lise de Vulnerabilidades Comuns
# ===========================================
def check_common_vulns():
    """Verifica configura√ß√µes inseguras comuns"""
    vulns = []
    
    # 1. Verifica se a UAC est√° desativada
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 
                           r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System")
        uac = winreg.QueryValueEx(key, "EnableLUA")[0]
        if uac == 0:
            vulns.append("UAC desativado (EnableLUA=0)")
    except Exception:
        pass
    
    # 2. Verifica compartilhamentos de rede abertos
    shares = list_network_shares()
    if shares:
        vulns.append(f"Compartilhamentos de rede detectados: {shares}")
    
    # 3. Verifica servi√ßos vulner√°veis
    vuln_services = check_services()
    if vuln_services:
        vulns.append(f"Servi√ßos potencialmente vulner√°veis: {vuln_services}")
    
    return vulns

def list_network_shares():
    """Lista compartilhamentos de rede acess√≠veis"""
    try:
        result = subprocess.run(['net', 'share'], capture_output=True, text=True)
        return result.stdout if result.returncode == 0 else None
    except Exception:
        return None

def check_services():
    """Identifica servi√ßos com configura√ß√µes inseguras"""
    vulnerable = []
    try:
        output = subprocess.run(['sc', 'query'], capture_output=True, text=True).stdout
        services = [line.split()[1] for line in output.splitlines() if "SERVICE_NAME" in line]
        
        for service in services[:10]:  # Limita a verifica√ß√£o
            config = subprocess.run(['sc', 'qc', service], capture_output=True, text=True)
            if "ERROR" not in config.stdout:
                if "SERVICE_START_NAME" in config.stdout and "LocalSystem" in config.stdout:
                    vulnerable.append(service)
    except Exception:
        pass
    
    return vulnerable

# ===========================================
# üìÅ 3. Auditoria de Permiss√µes de Arquivos
# ===========================================
def audit_file_permissions(path="C:\\Program Files", verbose=False):
    """Verifica arquivos com permiss√µes excessivas"""
    insecure_files = []
    try:
        for root, _, files in os.walk(path):
            for file in files:
                full_path = os.path.join(root, file)
                try:
                    # Verifica se o arquivo √© acess√≠vel por todos
                    if os.access(full_path, os.R_OK | os.W_OK | os.X_OK):
                        insecure_files.append(full_path)
                        if verbose:
                            su.message(f"Permiss√£o excessiva: {full_path}", "warning")
                except Exception:
                    continue
            if len(insecure_files) > 50:  # Limita a varredura
                break
    except Exception as e:
        su.message(f"Erro na auditoria: {e}", "error")
    
    return insecure_files

# ===========================================
# üîó 4. Teste de Portas e Servi√ßos de Rede
# ===========================================
def port_scan(target="localhost", ports="1-1024", timeout=1):
    """Scanner de portas b√°sico"""
    open_ports = []
    start_port, end_port = map(int, ports.split('-'))
    
    su.message(f"Scanning {target} ports {start_port}-{end_port}...", "info")
    
    for port in range(start_port, end_port + 1):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                result = s.connect_ex((target, port))
                if result == 0:
                    service = socket.getservbyport(port, 'tcp') if port <= 1024 else "unknown"
                    open_ports.append((port, service))
                    su.message(f"Porta {port} ({service}) aberta", "success")
        except (socket.error, socket.timeout):
            continue
        except Exception as e:
            su.message(f"Erro ao escanear porta {port}: {e}", "error")
    
    return open_ports

# ===========================================
# üìù 5. Gera√ß√£o de Relat√≥rios
# ===========================================
def generate_report(output_file="pentest_report.html"):
    """Gera relat√≥rio HTML com os resultados"""
    report = f"""
    <html>
    <head><title>Relat√≥rio de Teste de Penetra√ß√£o</title></head>
    <body>
    <h1>Relat√≥rio de Seguran√ßa</h1>
    <h2>Informa√ß√µes do Sistema</h2>
    <pre>{json.dumps(system_recon(False), indent=2)}</pre>
    
    <h2>Vulnerabilidades Detectadas</h2>
    <ul>
    {"".join(f"<li>{vuln}</li>" for vuln in check_common_vulns())}
    </ul>
    
    <h2>Portas Abertas</h2>
    <pre>{port_scan()}</pre>
    </body>
    </html>
    """
    
    with open(output_file, "w") as f:
        f.write(report)
    
    su.message(f"Relat√≥rio gerado: {output_file}", "success")
    return output_file

# ===========================================
# üõ°Ô∏è 6. Simulador de Ataques (Para Testes)
# ===========================================
def simulate_attack(attack_type):
    """Simula t√©cnicas de ataque para teste de defesa"""
    simulations = {
        'bruteforce': lambda: su.message("Simulando ataque de for√ßa bruta...", "warning"),
        'dos': lambda: su.message("Simulando nega√ß√£o de servi√ßo...", "warning"),
        'phishing': lambda: su.message("Simulando e-mail de phishing...", "warning")
    }
    
    if attack_type in simulations:
        return simulations[attack_type]()
    else:
        su.message("Tipo de simula√ß√£o inv√°lido", "error")
        return False

# ===========================================
# üßπ 7. Limpeza Segura
# ===========================================
def secure_cleanup():
    """Remove arquivos tempor√°rios e logs"""
    temp_files = su.find(os.environ['TEMP'], ext=".tmp")
    for file in temp_files:
        try:
            os.remove(file)
            su.message(f"Arquivo tempor√°rio removido: {file}", "debug")
        except Exception as e:
            su.message(f"Erro ao remover {file}: {e}", "error")
    
    su.message("Limpeza conclu√≠da", "success")

if __name__ == "__main__":
    su.message("=== Ethical Penetration Testing Toolkit ===", "info")
    su.message("Use apenas em sistemas com permiss√£o expl√≠cita!", "warning")
    
    # Exemplo de uso
    system_recon()
    vulns = check_common_vulns()
    if vulns:
        su.message("Vulnerabilidades encontradas:", "error")
        for vuln in vulns:
            print(f"- {vuln}")
    else:
        su.message("Nenhuma vulnerabilidade cr√≠tica encontrada", "success")
    
    generate_report()
